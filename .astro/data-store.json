[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.2.5","content-config-digest","316902b28d768083","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://oscartegiffel.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":false,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true},\"redirects\":{},\"prefetch\":true,\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":\"prism\",\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"serializeConfig\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,27,28,38,39,52,53,66,67,77,78,91,92,101,102,111,112,125,126,140,141,150,151],"08_typescript_satisfies",{"id":11,"data":13,"body":21,"filePath":22,"assetImports":23,"digest":25,"deferredRender":26},{"cover":14,"description":15,"publishDate":16,"tags":17,"title":20},"__ASTRO_IMAGE_./images/08.webp","A quick note to self about the `satisfies` operator in TypeScript",["Date","2025-01-23T00:00:00.000Z"],[18,19],"typescript","note to self","TypeScript's satisfies Operator: A Quick Note to Self","Just jotting down some key points about `satisfies` because I keep mixing up its use cases with type annotations.\n\nHere's the thing - `satisfies` is like a type-checker that doesn't narrow down the type inference. Think of it as telling TypeScript \"hey, verify this matches the type, but don't lock it down.\"\n\n```typescript\n// With type annotation\nconst colors: Record\u003Cstring, string> = {\n  primary: '#0047AB',\n  secondary: '#6082B6'\n} // Type is exactly Record\u003Cstring, string>\n\n// With satisfies\nconst colors2 = {\n  primary: '#0047AB',\n  secondary: '#6082B6'\n} satisfies Record\u003Cstring, string>\n// Type preserves literal types: { primary: \"#0047AB\", secondary: \"#6082B6\" }\n```\n\nThe real magic happens when combining `as const` with `satisfies`. It's like putting your object in a type-safe freezer:\n\n```typescript\nconst theme = {\n  colors: {\n    primary: '#0047AB',\n    secondary: '#6082B6'\n  },\n  fontSize: {\n    small: 12,\n    medium: 16\n  }\n} as const satisfies {\n  colors: Record\u003Cstring, string>,\n  fontSize: Record\u003Cstring, number>\n}\n\n// Now we get autocomplete for 'primary' and 'secondary'\n// AND type checking ensures we're using strings for colors\ntheme.colors.primary // Autocomplete works!\n```\n\n## Real-World Use Cases\n\nAn common use case I encountered is when working with API responses.\n\n### API Response Typing\n\nWhen dealing with API responses, `satisfies` shines by ensuring type safety while preserving specific values:\n\n```typescript\nconst apiResponse = {\n  status: 200,\n  data: {\n    users: [{\n      id: 1,\n      role: 'admin' as 'admin' | 'user'\n    }]\n  }\n} satisfies APIResponse\n// Now we get exact types for status (200) and role ('admin')\n```\n\n### Configuration Objects\n\nPerfect for environment variables and feature flags:\n\n```typescript\nconst config = {\n  api: {\n    endpoint: process.env.API_ENDPOINT,\n    timeout: 5000\n  },\n  features: {\n    darkMode: true,\n    beta: {\n      enabled: false,\n      users: ['admin@example.com']\n    }\n  }\n} as const satisfies AppConfig\n\n// TypeScript knows config.features.darkMode is specifically boolean\n// and config.features.beta.users is readonly string[]\n```\n\n## Common Gotchas\n\n1. Array Type Inference:\n\n```typescript\n// This loses tuple type inference\nconst tuple = [1, 'two', true] satisfies [number, string, boolean]\n// Use as const to preserve tuple types\nconst tuple = [1, 'two', true] as const satisfies readonly [number, string, boolean]\n```\n\n2. Nested Object Properties:\n\n```typescript\nconst settings = {\n  theme: {\n    colors: {\n      primary: '#000'\n    }\n  }\n} satisfies Settings\n// Without as const, theme.colors.primary is still widened to string\n```\n\n> __Note to future self__: Use `satisfies` when you want type checking without losing literal types, and combine with `as const` when you want both immutability and precise type inference. Type annotations are still useful when you explicitly want to widen the type.","src/content/blog/08_typescript_satisfies.mdx",[24],"./images/08.webp","52aa8f8260f5c18c",true,"03_drizzle",{"id":27,"data":29,"body":35,"filePath":36,"digest":37,"deferredRender":26},{"description":30,"publishDate":31,"tags":32,"title":34},"A deep dive into Drizzle vs. Prisma. Discover the challenges of complex relational queries, the importance of developer experience, and valuable lessons learned when switching database tools. Perfect for TypeScript developers seeking insights on ORM selection and performance optimization.",["Date","2024-03-01T00:00:00.000Z"],[18,33],"orm","Moving to Drizzle and back","In the ever-evolving world of software development, exploring new tools and technologies is essential. As a seasoned software engineer, I've always advocated for trying new approaches. Recently, I decided to put my own advice into practice by experimenting with Drizzle, an alternative to my usual ORM of choice.\n\nMy primary requirements for an ORM are straightforward: excellent developer experience, a clean API for queries and mutations, and robust TypeScript support. Unfortunately, Drizzle fell short of these expectations, particularly in one crucial use case.\n\nConsider a simple schema with users and groups:\n\n```typescript\nexport const users = mysqlTable(\"users\", {\n  id: varchar(\"id\", { length: 256 }).primaryKey(),\n  name: varchar(\"name\", { length: 256 }).notNull(),\n});\n\nexport const groups = mysqlTable(\"groups\", {\n  id: varchar(\"id\", { length: 256 }).primaryKey(),\n  name: varchar(\"name\", { length: 256 }).notNull(),\n});\n```\n\nI opted for varchar as the id type, generating UUIDs in the application rather than relying on database-generated ids. This approach sidesteps potential issues with MySQL's `LAST_INSERT_ID()` function in serverless environments.\n\nCreating a many-to-many relationship between these tables in Drizzle requires manual creation of a junction table:\n\n```typescript\nexport const usersToGroups = mysqlTable(\n  \"users_to_groups\",\n  {\n    userId: varchar(\"user_id\")\n      .notNull()\n      .references(() => users.id),\n    groupId: varchar(\"group_id\")\n      .notNull()\n      .references(() => groups.id),\n  },\n  (t) => ({\n    pk: primaryKey(t.userId, t.groupId),\n  }),\n);\n\n// Relation definitions omitted for brevity\n```\n\nWhile this setup seems reasonable, the API for querying related data leaves much to be desired. Fetching a single user with their associated group requires a convoluted query structure:\n\n```typescript\nawait db.query.users.findFirst({\n  with: {\n    groups: {\n      with: {\n        group: true,\n      },\n      where: eq(usersToGroupsRelations.userId, input.id),\n    },\n  },\n  where: eq(usersToGroupsRelations.id, input.id),\n});\n```\n\nThe resulting data structure is equally cumbersome:\n\n```json\n{\n  \"id\": \"XRdUD20AfH422nXKI72HW\",\n  \"name\": \"test\",\n  \"groups\": [\n    {\n      \"userId\": \"XRdUD20AfH422nXKI72HW\",\n      \"groupId\": \"_VQnVW4cZj4HvnCC1W9Lr\",\n      \"group\": {\n        \"id\": \"_VQnVW4cZj4HvnCC1W9Lr\",\n        \"name\": \"sdf\",\n        \"description\": \"sdf\",\n        \"quantity\": 0,\n        \"unit\": \"kg\"\n      }\n    }\n  ]\n}\n```\n\nThis experience led me back to Prisma, which offers a more intuitive API and cleaner data structures for managing relationships. While Drizzle may have its merits, it failed to provide the seamless developer experience I sought in this particular scenario.\n\nIn the end, this journey reinforced the importance of thoroughly evaluating tools against specific use cases before committing to a switch. Sometimes, the grass isn't always greener on the other side, and there's value in recognizing when to stick with a tried-and-true solution.","src/content/blog/03_drizzle.mdx","d2841bdebba28668","10_taking_the_stairs",{"id":38,"data":40,"body":47,"filePath":48,"assetImports":49,"digest":51,"deferredRender":26},{"cover":41,"description":42,"publishDate":43,"tags":44,"title":46},"__ASTRO_IMAGE_./images/10.webp","An ode to taking the harder path in life as an investment in personal growth.",["Date","2025-01-31T00:00:00.000Z"],[45],"personal growth","Taking the Stairs","A while ago, I encountered an article that used \"taking the stairs\" as a metaphor for choosing the harder path in life. The imagery stuck with me. In today's world of Large Language Models where shortcuts are just a prompt away, maintaining the discipline to take the \"stairs\" – to embrace the harder path – becomes increasingly difficult. Yet this choice often makes all the difference in our personal and professional growth.\n\n## My Early Days of Learning\n\nMy programming journey began like many others – searching for the easy way out. I found myself stuck daily on what seemed like straightforward tasks, desperately seeking quick solutions. I remember posting on Stack Overflow, only to receive the response: \"We are not going to do your homework.\" While frustrating at the time, this tough love proved invaluable.\n\nEventually, programming clicked for me, but not through copying and pasting solutions. It happened through countless nights of wrestling with problems, sometimes solving them directly, other times discovering exciting tangential paths that expanded my knowledge in unexpected ways. The breakthrough came when I realized that real learning wasn't about finding answers – it was about understanding the answers.\n\n## Learning in the Age of AI\n\nLooking back, I wonder how different my learning experience would be in today's environment, where LLMs offer instant solutions to complex problems. While these tools are powerful aids, they can also become crutches that prevent deep understanding. To those embarking on their learning journey, especially in programming, I offer this advice: resist the urge to immediately search for answers. Take a moment to think, struggle, and explore.\n\n## Why Take the Stairs?\n\nTaking the stairs means:\n\n- Building mental resilience through productive struggle\n- Developing problem-solving skills that no AI can replicate\n- Creating deeper neural connections through active learning\n- Finding unexpected opportunities and insights along the way\n\n## Know When to Take the Stairs\n\nOne of the most crucial skills in software development isn't technical at all – it's knowing when to invest in deep understanding versus when to implement a quick solution. It's about being strategic with your learning journey.\n\nAsk yourself these questions when facing a problem:\n\n### Is This Part of Your Foundation?\n\nIf you're working with core concepts like:\n\n- Data structures and algorithms\n- Language fundamentals\n- System design principles\n- State management\n- Authentication flows\n\nThen you absolutely need to take the stairs. These are the building blocks that will shape how you think about problems for years to come. When I skipped understanding promises in JavaScript early in my career, I spent months writing fragile code that I couldn't debug effectively. The time I \"saved\" led to weeks of frustration later.\n\n### Is This a One-Off Solution?\n\nSometimes you genuinely just need to convert a timestamp or center a div. In these cases, it's okay to take the elevator. The key is being honest with yourself about what category the problem falls into.\n\n### The \"Future You\" Test\n\nWhen deciding whether to invest time in understanding something deeply, I ask myself:\n\n- Will I need to modify this code in the future?\n- Would I be comfortable debugging this at 3 AM during a production issue?\n- Could this become a critical part of the system?\n- Will other developers need to understand my implementation?\n\nIf any of these answers is \"yes,\" it's time to take the stairs.\nOnly through struggle you can learn to debug\nRemember: You don't need to deeply understand every line of code you write, but you absolutely need to understand the code that matters. The trick is developing the wisdom to know the difference.\n\n## Only through struggle you can learn to debug\n\nPerhaps the most valuable skill you can develop through taking the stairs is the art of debugging. It's a skill that no tutorial can truly teach and no AI can replicate – because debugging is more than just fixing errors. It's about developing intuition, pattern recognition, and systematic problem-solving abilities.\n\nWhen you encounter a bug you gather clues through error messages, develop hypotheses about what might be wrong, and systematically test your theories. This investigative mindset only develops through hands-on experience and, yes, plenty of frustration.\n\nThrough debugging yourself, you develop:\n\n- The instinct to check variable scope when seeing \"undefined\" errors\n- The habit of reading error messages thoroughly instead of just copying them\n- The ability to work backward from an error to its root cause\n- The confidence to tackle similar issues in the future\n\n## The 72-Hour Challenge\n\nHere's a challenge for myself and you: For the next 72 hours, when you encounter a programming problem, follow these steps:\n\n1. Set a 15-minute timer\n2. Before searching for solutions or asking AI, write down:\n   - What you think the problem is asking\n   - What approaches you might try\n   - What pieces you don't understand\n3. Attempt at least one solution, even if you think it's wrong\n4. Only after these steps, if still stuck, seek help\n\nDocument your experience. You might be surprised how often you can solve problems with just a bit more patience and persistence. Even when you don't find the solution, you'll likely understand it better when you do look it up.\n\n## The Path Forward\n\nNot every problem has a clear-cut solution that can be prompted from an AI. The most valuable skills in programming – and in life – come from developing the ability to think critically, analyze thoroughly, and persist through challenges. While LLMs are powerful tools, they should augment our learning journey, not replace the valuable experience of figuring things out on our own.\n\n> Remember: The view is always better when you take the stairs.","src/content/blog/10_taking_the_stairs.mdx",[50],"./images/10.webp","71be0649e4985ecf","09_think_originally",{"id":52,"data":54,"body":61,"filePath":62,"assetImports":63,"digest":65,"deferredRender":26},{"cover":55,"description":56,"publishDate":57,"tags":58,"title":60},"__ASTRO_IMAGE_./images/09.webp","How to think more creatively and develop original ideas",["Date","2025-01-28T00:00:00.000Z"],[59],"self-help","How to Think Originally","We all want to think more creatively and develop original ideas, but how? After watching an insightful video by Odysseas, I've been reflecting on five key habits that can transform how we think. Let me share them with you in my own words.\n\nFirst, we need to be more selective about what we feed our minds. __Think of your brain like a garden__ – if you plant the same seeds as everyone else, you'll grow the same flowers. Instead of reaching for those popular self-help books that everyone's reading, try exploring different genres, unusual topics, or overlooked classics. Your unique collection of knowledge will naturally lead to original thoughts.\n\nSecond, and this one really hit home for me, __we need to create space for thinking__. We're all guilty of constantly consuming content – jumping from podcasts to videos to articles. I myself am guilty of this. But here's the thing: our minds need quiet time to process everything we learn. It's like trying to have a conversation while everyone's talking at once. Sometimes, we need to just sit with our thoughts and let them develop.\n\nThe third habit is beautifully simple: __get out and experience life__. It's funny how we often look for inspiration while sitting at our desks, staring at screens. Real inspiration comes from living – walking through a busy street, traveling to new places, or even just having a genuine conversation with someone different from us. The world is full of inspiration if we just step out to find it.\n\nFourth, __don't wait for the perfect moment to create__. Start now, start messy, just start. I've found this to be incredibly true – the act of creating something, anything, generates more ideas than just thinking about creating ever could. Each small step forward opens up new possibilities you couldn't see before.\n\nFinally, __embrace what makes you different__. Your unique combination of interests and experiences is your superpower. Maybe you're the only person who loves both quantum physics and knitting, or medieval history and hip-hop. These unusual combinations are exactly what lead to the most original ideas.\n\n> Remember, original thinking isn't about reinventing everything – it's about seeing the world through your unique lens and having the courage to share that perspective with others.","src/content/blog/09_think_originally.mdx",[64],"./images/09.webp","6741bcd4eb6b5147","04_my-system",{"id":66,"data":68,"body":74,"filePath":75,"digest":76,"deferredRender":26},{"publishDate":69,"tags":70,"title":73},["Date","2024-01-01T00:00:00.000Z"],[71,72,45],"productivity","software development","A Software Developer's Journey to Productivity","> The cursor blinked mockingly on my screen, a stark reminder of another hour lost to distraction.\n\nAs a software developer, my inability to focus wasn't just frustrating—it was holding be back. This moment became my catalyst for change, pushing me to craft a productivity system that would work with my mind, not against it.\n\nI've wandered through the labyrinth of productivity techniques, from the Pomodoro Technique to GTD (Getting Things Done). I've followed countless YouTubers, each promising the ultimate solution. But it wasn't until I stumbled upon a content creator who married digital efficiency with analog mindfulness that I found my path.\n\n## The Evolution of a System\n\nMy journey began with rigid structures—forced daily writing, strict schedules, and an overwhelming number of apps. The result? Paralysis. The pressure to be perfectly productive ironically led to stagnation. I realized that the key wasn't in following someone else's system to the letter, but in creating a flexible framework that could adapt to my needs as a developer and as a human being.\n\n### The Digital-Analog Balance\n\nAs software developers, we live in a digital world. Our work demands hours behind screens, diving deep into codebases and digital documentation. This immersion, while necessary, can be all-consuming. I found myself losing touch with the physical world, my thoughts becoming as ephemeral as the pixels on my screen.\n\nThe solution? A return to analog methods, balanced with digital tools that complement our tech-centric work. This hybrid approach allows me to stay connected to both worlds, leveraging the strengths of each.\n\n## The Analog Core\n\nMy analog system consists of four notebooks, each serving a distinct purpose. These physical journals form the bedrock of my productivity and self-reflection practice. Most of these idea's came from my inspiration [Parker's Pensees](https://www.youtube.com/c/ParkersPens%C3%A9es)\n\n### 1. The Skill Acquisition Notebook\n\nCurrently dedicated to Japanese, this notebook embodies the concept of focused skill development. As developers, we're constantly learning new languages and frameworks. This dedicated space allows for intentional practice and progress tracking.\n\n**Tip**: Choose a consistent time each day for skill practice. Even 15 minutes can lead to significant progress over time.\n\n### 2. The Philosophical Journal\n\nThis is where I wrestle with complex ideas and engage in metacognition—a crucial skill for problem-solving in software development. I follow a structured approach:\n\n1. Clearly state the problem or concept\n2. List arguments and counter-arguments\n3. Draw conclusions or identify areas for further exploration\n\nThis process has improved my ability to break down complex coding challenges and architecture decisions. I got this idea from\n\n### 3. The Commonplace Book\n\nInspired by great thinkers throughout history, this notebook is a collection of wisdom—quotes, code snippets, architectural patterns, and insights from tech talks. It's become an invaluable resource when I'm stuck on a problem or need inspiration for a new project.\n\n### 4. The Pocket Notebook\n\nMy constant companion, this small Leuchtturm1917 captures fleeting ideas and observations. Many of my most innovative solutions have started as quick notes jotted down during a coffee break or commute.\n\n### The Compendium\n\nA larger project, my compendium is a curated collection of life wisdom and technical knowledge. It's my personal encyclopedia, growing slowly but steadily with carefully selected insights.\n\n## Digital Tools for the Modern Developer\n\nWhile analog methods ground my thinking, digital tools amplify my productivity. Here's how I use them:\n\n### 1. Raindrop: The Knowledge Repository\n\nAs developers, we encounter a wealth of valuable articles, documentation, and resources. Raindrop serves as my digital library, meticulously tagged and organized for easy retrieval.\n\n**Alternative**: Pocket offers similar functionality with a focus on readability.\n\n### 2. Capacities: The Digital Second Brain\n\nThis tool has revolutionized my note-taking for work-related topics. Using the second brain paradigm, I connect ideas across projects and technologies, often finding unexpected solutions to current problems in past notes.\n\n**Alternative**: Obsidian offers a similar experience with a focus on local storage and customization.\n\n### 3. Eraser.io: The Digital Whiteboard\n\nFor visualizing complex systems or explaining architectural decisions to teammates, Eraser.io has become indispensable. Its developer-friendly features make it superior to general-purpose drawing tools.\n\n**Alternative**: [Excalidraw](https://excalidraw.com) offers robust collaboration features for team-wide diagramming.\n\n### 4. Things: The Task Manager\n\nMy to-do list is structured to balance immediate needs with long-term goals:\n\n- Inbox: The catch-all for new tasks and ideas\n- Today: Must-do items for the current day\n- Anytime: Important but not time-sensitive tasks\n- Someday: Long-term ideas and projects\n- Projects: Multi-step tasks grouped by objective\n- This Year/Next Year: Long-term planning and goal-setting\n\nThis structure helps me maintain focus on current sprint tasks while still progressing towards broader career goals.\n\n**Alternative**: Todoist offers cross-platform synchronization and natural language input.\n\n### 5. Habitify: Building Better Dev Habits\n\nI use this to track habits that improve my skills and well-being as a developer. Current focuses include daily code reviews and regular stretching to combat the effects of long coding sessions.\n\n**Alternative**: Loop Habit Tracker is a great open-source option for Android users.\n\n### 6. Day One: The Digital Time Capsule\n\nRather than forced journaling, I use Day One to capture significant moments in my developer journey—screenshots of major bug fixes, voice notes after important meetings, or photos of whiteboard sessions. It's become a wonderful way to track my growth and celebrate wins.\n\n**Alternative**: Journey offers a similar experience with a focus on privacy and encryption.\n\n## Overcoming Challenges and Adapting the System\n\nImplementing this system wasn't without its hurdles. One major challenge was context switching between analog and digital tools. The solution? Designated times for each, with mornings reserved for analog reflection and planning, and digital tools taking precedence during work hours.\n\nAnother issue was maintaining consistency, especially with the analog components. I overcame this by linking new habits to existing ones—for example, my commonplace book is now part of my morning coffee routine.\n\n## Conclusion: Your Journey to Productivity\n\nRemember, productivity is deeply personal. While this system works for me, I encourage you to experiment and find what resonates with your workflow. Start small—perhaps with a pocket notebook or a new task management app—and build from there.","src/content/blog/04_my-system.mdx","071e57550855ce31","05_better-react-props",{"id":77,"data":79,"body":86,"filePath":87,"assetImports":88,"digest":90,"deferredRender":26},{"cover":80,"description":81,"publishDate":82,"tags":83,"title":85},"__ASTRO_IMAGE_./images/05.webp","Learn how to write more type-safe React components using discriminated unions - a powerful TypeScript pattern that helps prevent prop-related bugs and improves code maintainability. This technical guide demonstrates practical examples of implementing discriminated unions in both React props and reducers to ensure better component design and state management.",["Date","2024-02-01T00:00:00.000Z"],[84,18],"react","Better React Props","A simple pattern, yet not widely utilized, is _discriminated unions_. When using React, you can enhance your props by employing discriminated unions. This powerful pattern can be employed in various ways, although I often find it underutilized. In this post, I will demonstrate how to utilize it to improve React props.\n\nLet's consider the following component:\n\n```tsx\ntype Props = {\n  onClick: () => void;\n};\n\nfunction Button(props: Props): JSX.Element {\n  return \u003Cbutton onClick={props.onClick}>Click me\u003C/button>;\n}\n```\n\nThis Button component receives an `onClick` function, which is the most common use case. However, what if we want to pass an `href` prop instead and render an `a` tag? We could do something like this:\n\n```tsx\ntype Props = {\n  onClick?: () => void;\n  href?: string;\n};\n\nfunction Button(props: Props): JSX.Element {\n  if (props.href) {\n    return (\n      \u003Ca href={props.href} onClick={props.onClick}>\n        Click me\n      \u003C/a>\n    );\n  }\n\n  if (props.onClick) {\n    return \u003Cbutton onClick={props.onClick}>Click me\u003C/button>;\n  }\n\n  return null;\n}\n```\n\nWhile this solution works, it is not ideal. We need to check for the existence of each prop and return the correct element. Additionally, we can pass both the `onClick` and `href` props, which is not desirable. To address these concerns, we can utilize discriminated unions. By doing so, we can create a type that only allows one of the props to be passed. Let's see how that looks:\n\n```tsx\ntype Props =\n  | {\n      type: \"button\";\n      onClick: () => void;\n    }\n  | {\n      type: \"link\";\n      href: string;\n    };\n\n// Same button implementation as before\n// However, when using this component and passing both props, an error will be raised\n\u003CButton type=\"button\" onClick={() => {}} href=\"/home\" />;\n```\n\nThis approach provides several benefits:\n\n1. It ensures that only valid combinations of props are used. You can't pass both onClick and href props simultaneously.\n2. It provides clear guidance to the user of the component on which props are allowed.\n3. It improves type safety, as TypeScript will catch any incorrect usages at compile-time.\n\n## Using Discriminated Unions on React Reducers\n\nDiscriminated unions can also be useful when working with reducers in React. They provide a way to handle different actions and their associated payloads in a type-safe manner. Here's an example:\n\n```ts\ntype State =\n  | { status: \"pending\" }\n  | { status: \"loading\" }\n  | { status: \"success\"; data: Book[] }\n  | { status: \"error\"; error: any };\n\ntype Action =\n  | { type: \"FETCH_PENDING\" }\n  | { type: \"FETCH_LOADING\" }\n  | { type: \"FETCH_SUCCESS\"; payload: Book[] }\n  | { type: \"FETCH_ERROR\"; payload: any };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"FETCH_PENDING\":\n      return { status: \"pending\" };\n    case \"FETCH_LOADING\":\n      return { status: \"loading\" };\n    case \"FETCH_SUCCESS\":\n      return { status: \"success\", data: action.payload };\n    case \"FETCH_ERROR\":\n      return { status: \"error\", error: action.payload };\n    default:\n      return state;\n  }\n}\n\n// Usage\nconst initialState: State = { status: \"pending\" };\nconst [state, dispatch] = useReducer(reducer, initialState);\n\n// Dispatch actions\ndispatch({ type: \"FETCH_PENDING\" });\ndispatch({ type: \"FETCH_LOADING\" });\ndispatch({ type: \"FETCH_SUCCESS\", payload: books });\ndispatch({ type: \"FETCH_ERROR\", payload: error });\n```\n\nIn this example, we use discriminated unions to represent different states of a fetch operation in the State type. Each state, such as 'pending', 'loading', 'success', or 'error', includes additional data.\n\nThe Action type defines various actions that can be dispatched to the reducer, representing different state transitions. Each action has a specific type and optional data associated with it.\n\nBy using a switch statement, the reducer function handles each action type individually and updates the state accordingly based on the current state and the action received.\n\nUsing discriminated unions in this way improves type safety and makes managing state in React applications more straightforward for developers.\n\n---\n\nThe importance of this is garanty of type safety. By utilizing discriminated unions in React props and reducers, we enhance type safety, ensuring that only valid combinations of props are used and that actions and state transitions are handled correctly. TypeScript, with its static type checking, becomes a valuable tool in catching potential errors and providing early feedback during development. With type safety, we can confidently refactor, collaborate, and build robust React applications that are less prone to runtime errors, improving overall development productivity and code quality.\n\n### Useful Sources\n\n- [Discriminating Unions Documentation](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#discriminating-unions)","src/content/blog/05_better-react-props.mdx",[89],"./images/05.webp","9c23afd88c173fe6","02_maturity",{"id":91,"data":93,"body":98,"filePath":99,"digest":100,"deferredRender":26},{"publishDate":94,"tags":95,"title":97},["Date","2023-08-04T00:00:00.000Z"],[96],"personal","Maturity","On my 31st birthday, I attempted to put into words the changes I had undergone in this new chapter of my life. However, the words I wrote didn't resonate with me. I struggled to express the shift that had taken place within me.\n\nIn the past, I would shy away from confrontations, letting them build up in my mind and leave me feeling inadequate. I avoided difficult conversations, fearing their impact on my self-image. But there came a turning point, a moment of realization.\n\nReflecting on the past year, I found myself receiving a consistent message from various people: \"You have grown.\" Hearing this made me pause and ponder over what they were seeing in me.\n\nAs I hit the milestone of turning 30, I became more determined to discover my true self and live authentically. I sought inspiration from those around me, molding the person I aspired to become. Personal growth became my priority, pushing me to embrace assertiveness, vulnerability, openness, and honesty. Engaging in discussions and taking courses further fueled my journey, leading to remarkable personal development.\n\nToday, I can genuinely say that I am happy with who I am. I now own both my strengths and weaknesses, recognizing areas for improvement without undermining my accomplishments. Confidence in my abilities shines through, making me more assertive in pursuing my goals. The transformation I experienced has been a journey of self-discovery and learning, and it has brought me closer to the person I always wanted to be.\n\n---\n\nIn the past, I would shy away,  \nFrom confrontations, I'd stray.  \nNow I've learned, and I can say,  \nConfronting helps me find my way.","src/content/blog/02_maturity.mdx","7eaa6b91e3d505be","03_copy_object",{"id":101,"data":103,"body":108,"filePath":109,"digest":110,"deferredRender":26},{"publishDate":104,"tags":105,"title":107},["Date","2023-12-23T00:00:00.000Z"],[18,106],"javascript","How to Copy an Object in Javascript","A common task in JavaScript, a language that is easy to learn but full of nuances, is copying objects. Let's explore how to do this effectively.\n\n### ES5 Clone Function\n\nIn ES5, we often used a custom clone function:\n\n```javascript\n// ES5 clone function\nfunction clone(obj) {\n  if (null == obj || \"object\" != typeof obj) return obj;\n  var copy = obj.constructor();\n  for (var attr in obj) {\n    if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\n  }\n  return copy;\n}\n\nvar obj = { a: 1, b: 2, c: [1, 2, 3] };\nvar copy = clone(obj);\n```\n\n### ES6 Spread Operator\n\nWith ES6, we shifted to using the spread operator:\n\n```javascript\n// ES6 spread operator\nconst obj = { a: 1, b: 2, c: [1, 2, 3] };\nconst copy = { ...obj };\n```\n\nThese were the primary solutions available at the time. However, both create a shallow copy, which can lead to unexpected behaviors.\n\n### Shallow Copy Issue\n\nA shallow copy only duplicates the first level of the object:\n\n```javascript\nconst obj = { a: 1, b: 2, c: [1, 2, 3] };\nconst copy = { ...obj };\ncopy.c.push(4);\nconsole.log(obj.c); // Output: [1, 2, 3, 4]\nconsole.log(copy.c); // Output: [1, 2, 3, 4]\n```\n\nThe modification of `copy.c` also affects `obj.c` because they reference the same array. This illustrates the limitations of shallow copying.\n\n### Deep Copy with JSON Methods\n\nTo create a deep copy, one common method is using JSON:\n\n```javascript\nconst obj = { a: 1, b: 2, c: [1, 2, 3] };\nconst copy = JSON.parse(JSON.stringify(obj));\ncopy.a = 3;\nconsole.log(obj.a); // Output: 1\nconsole.log(copy.a); // Output: 3\n```\n\nThis method is straightforward but has limitations, including poor performance and inability to handle certain data types and circular references.\n\n### Deep Copy with `structuredClone`\n\nThe most recent and optimal solution is `structuredClone`:\n\n```javascript\nconst obj = { a: 1, b: 2, c: [1, 2, 3] };\nconst copy = structuredClone(obj);\ncopy.a = 3;\nconsole.log(obj.a); // Output: 1\nconsole.log(copy.a); // Output: 3\n```\n\n`structuredClone` is fast, supports all data types, and handles circular references. It's supported by all major browsers.\n\n> **Note:** `structuredClone` does not clone functions, DOM nodes, property descriptors, setters, or getters. Also, the prototype chain is not duplicated, so the clone is no longer an instance of the original class.\n\n### Conclusion\n\nUnderstanding the nuances of copying objects in JavaScript is crucial for ensuring data integrity and avoiding unexpected behaviors in your applications. Depending on your needs, you can choose between shallow and deep copying methods. Choose wisely.","src/content/blog/03_copy_object.mdx","6b67a17bd39bd6b4","06_error_handling_in_typescript",{"id":111,"data":113,"body":120,"filePath":121,"assetImports":122,"digest":124,"deferredRender":26},{"cover":114,"description":115,"publishDate":116,"tags":117,"title":119},"__ASTRO_IMAGE_./images/06.webp","Elevate your TypeScript error handling with the powerful 'Result' type. Learn how to implement this functional programming concept for clearer, safer, and more composable code that explicitly manages success and failure states.",["Date","2024-04-07T00:00:00.000Z"],[18,118],"error-handling","Effective Error Handling with Result Types in TypeScript","TypeScript, while powerful, lacks a built-in construct specifically designed for function-level error handling. The standard `Error` type, while useful, doesn't quite fit the bill for representing potential failures in a type-safe manner. Let's explore how we can fill this gap with a custom `Result` type.\n\n## The Result Type\n\nThe `Result` type encapsulates the outcome of a function that may succeed or fail. It adheres to two key principles:\n\n1. It can unwrap the underlying value.\n2. It allows building upon the underlying value.\n\nHere's a straightforward implementation:\n\n```typescript\nenum ResultKind {\n  OK = \"Ok\",\n  ERR = \"Err\",\n}\n\nexport type Result\u003CT, E> = Ok\u003CT> | Err\u003CE>;\n\ninterface ResultBase\u003CA, E> {\n  kind: ResultKind;\n  map\u003CB>(fn: (_: A) => B): Result\u003CB, E>;\n  bind\u003CB>(fn: (_: A) => Result\u003CB, E>): Result\u003CB, E>;\n  match\u003CB>(obj: { ok: (_: A) => B; err: (_: E) => B }): B;\n}\n\nexport type Ok\u003CA> = Readonly\u003CResultBase\u003CA, never> & { kind: ResultKind.OK; value: A }>;\n\nexport function ok\u003CA>(a: A): Ok\u003CA> {\n  return {\n    kind: ResultKind.OK,\n    value: a,\n    map(fn) {\n      return ok(fn(this.value));\n    },\n    bind(fn) {\n      return fn(this.value);\n    },\n    match({ ok }) {\n      return ok(this.value);\n    },\n  };\n}\n\nexport type Err\u003CE> = Readonly\u003CResultBase\u003Cnever, E> & { kind: ResultKind.ERR; error: E }>;\n\nexport function err\u003CE>(e: E): Err\u003CE> {\n  return {\n    kind: ResultKind.ERR,\n    error: e,\n    map() {\n      return this;\n    },\n    bind() {\n      return this;\n    },\n    match({ err }) {\n      return err(this.error);\n    },\n  };\n}\n```\n\n## Using the Result Type\n\nHere's how you might use the `Result` type in practice:\n\n```typescript\nfunction divide(a: number, b: number): Result\u003Cnumber, string> {\n  return b === 0 ? err(\"Division by zero\") : ok(a / b);\n}\n\n// Example usage\nconst result1 = divide(10, 2);\nconst result2 = divide(8, 0);\n\n// Pattern matching\nresult1.match({\n  ok: (value) => console.log(`Result: ${value}`),\n  err: (error) => console.error(`Error: ${error}`),\n});\n\nresult2.match({\n  ok: (value) => console.log(`Result: ${value}`),\n  err: (error) => console.error(`Error: ${error}`),\n});\n```\n\n## Benefits of the Result Type\n\nThis implementation shares some properties with monads, though it's a simplified version. The main advantages are:\n\n1. Improved function clarity: The return type explicitly indicates that an error might occur.\n2. Type safety: TypeScript ensures that both success and error cases are handled.\n3. Composability: Results can be chained together easily.\n\nWhile it would be ideal to have such functionality at the language level, this pattern provides a workable solution for more robust error handling in TypeScript applications.\n\n## Conclusion\n\nThe `Result` type offers a pragmatic approach to error handling in TypeScript. By adopting this pattern, you can write more predictable and maintainable code. Consider incorporating it into your projects and see how it impacts your error management strategy.\n\nWhile I encourage creating this pattern in your own projects, there are numerous projects that have amazing API's like [ts-results](https://github.com/vultix/ts-results).","src/content/blog/06_error_handling_in_typescript.mdx",[123],"./images/06.webp","9d8bde5cfddc203c","07_pattern-matching",{"id":125,"data":127,"body":135,"filePath":136,"assetImports":137,"digest":139,"deferredRender":26},{"cover":128,"description":129,"publishDate":130,"tags":131,"title":134},"__ASTRO_IMAGE_./images/07.webp","Discover how pattern matching can revolutionize your code in both Rust and TypeScript. This deep dive explores powerful techniques for handling complex data structures, streamlining conditional logic, and boosting code maintainability across diverse programming challenges.",["Date","2024-09-01T00:00:00.000Z"],[18,132,133],"rust","functional programming","Pattern Matching: From Rust to TypeScript","As a developer constantly seeking to refine my skills, I've found pattern matching to be a powerful technique, particularly prevalent in functional programming and languages like Rust. This post explores how we can bring similar functionality to TypeScript.\n\n## The Power of Pattern Matching\n\nPattern matching is a feature that allows you to match complex data structures against predefined patterns. It's particularly useful when dealing with diverse data formats or complex conditional logic.\n\nConsider a weather forecasting application that receives data in various formats (XML, JSON, plain text) from multiple providers. Pattern matching can simplify the extraction of essential information like temperature, wind speed, and humidity, making your code more readable and maintainable.\n\n## Rust's Native Pattern Matching\n\nRust provides built-in pattern matching using the `match` keyword:\n\n```rust\nenum Weather {\n    Sunny,\n    Cloudy,\n    Rainy\n}\n\nfn print_weather(weather: Weather) {\n    match weather {\n        Weather::Sunny => println!(\"It's a sunny day!\"),\n        Weather::Cloudy => println!(\"It's a cloudy day.\"),\n        Weather::Rainy => println!(\"It's raining outside.\"),\n    }\n}\n```\n\n### Exhaustive Checking in Rust\n\nOne of Rust's key strengths is exhaustive checking, which ensures all potential cases are handled:\n\n```rust\nenum TrafficLight {\n    Red,\n    Yellow,\n    Green,\n}\n\nfn action_based_on_light(light: TrafficLight) {\n    match light {\n        TrafficLight::Red => stop(),\n        TrafficLight::Yellow => slow_down(),\n        TrafficLight::Green => go(),\n    }\n}\n```\n\nOmitting any `TrafficLight` variant would result in a compilation error, preventing potential bugs where a case is not handled. This is a fairly trivial example, but let's look at a more complex use case:\n\n```rust\nenum Message {\n    Quit,\n    Move(i32, i32),\n    Write(String),\n    ChangeColor(i32, i32, i32),\n    Login(String, Option\u003CString>),\n}\n\nstruct User { id: u32, name: String, active: bool }\n\nfn process_message(msg: Message, user: Option\u003CUser>) {\n    match msg {\n        Message::Quit => println!(\"Quitting\"),\n        Message::Move(x, y) => println!(\"Moving to ({}, {})\", x, y),\n        Message::Write(text) if text.len() \u003C 10 => println!(\"Short: {}\", text),\n        Message::Write(text) => println!(\"Long: {:.10}...\", text),\n        Message::ChangeColor(r, g, b) => println!(\"Color: RGB({},{},{})\", r, g, b),\n        Message::Login(name, Some(pass)) if pass.len() >= 8 => println!(\"{} logged in\", name),\n        Message::Login(name, _) => println!(\"Login failed for {}\", name),\n    }\n\n    match user {\n        Some(User { id, name, active: true }) => println!(\"Active: {} (ID: {})\", name, id),\n        Some(User { name, .. }) => println!(\"Inactive: {}\", name),\n        None => println!(\"No user logged in\"),\n    }\n}\n```\n\nThis complex example demonstrates several advanced features of Rust's pattern matching:\n\n1. Enum matching with different variants\n2. Tuple destructuring (e.g., `Message::Move(x, y)`)\n3. Guards with `if` conditions (e.g., `if text.len() \u003C 10`)\n4. Matching on `Option` types\n5. Struct destructuring (e.g., `User { id, name, active: true }`)\n6. Using the `..` wildcard to ignore remaining fields\n\nThese features allow for concise and expressive handling of complex data structures and conditions.\n\n## TypeScript's Approach\n\nWhile TypeScript lacks native pattern matching, it offers alternatives:\n\n```typescript\ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; sideLength: number }\n  | { kind: \"rectangle\"; width: number; height: number };\n\nfunction calculateArea(shape: Shape): number {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    case \"rectangle\":\n      return shape.width * shape.height;\n    default:\n      throw new Error(\"Invalid shape\");\n  }\n}\n```\n\nLibraries like `ts-pattern` can enhance TypeScript's pattern matching capabilities. Here's a more complex example similar to the Rust one:\n\n```typescript\nimport { match, P } from \"ts-pattern\";\n\ntype Message =\n  | { type: \"Quit\" }\n  | { type: \"Move\"; x: number; y: number }\n  | { type: \"Write\"; text: string }\n  | { type: \"ChangeColor\"; r: number; g: number; b: number }\n  | { type: \"Login\"; name: string; password?: string };\n\ntype User = { id: number; name: string; active: boolean };\n\nfunction processMessage(msg: Message, user: User | null) {\n  match(msg)\n    .with({ type: \"Quit\" }, () => console.log(\"Quitting\"))\n    .with({ type: \"Move\", x: P.number, y: P.number }, ({ x, y }) => console.log(`Moving to (${x}, ${y})`))\n    .with({ type: \"Write\", text: P.when((t) => t.length \u003C 10) }, ({ text }) => console.log(`Short: ${text}`))\n    .with({ type: \"Write\" }, ({ text }) => console.log(`Long: ${text.slice(0, 10)}...`))\n    .with({ type: \"ChangeColor\", r: P.number, g: P.number, b: P.number }, ({ r, g, b }) =>\n      console.log(`Color: RGB(${r},${g},${b})`),\n    )\n    .with({ type: \"Login\", name: P.string, password: P.when((p) => p && p.length >= 8) }, ({ name }) =>\n      console.log(`${name} logged in`),\n    )\n    .with({ type: \"Login\" }, ({ name }) => console.log(`Login failed for ${name}`))\n    .exhaustive();\n\n  match(user)\n    .with({ active: true }, ({ id, name }) => console.log(`Active: ${name} (ID: ${id})`))\n    .with({ active: false }, ({ name }) => console.log(`Inactive: ${name}`))\n    .with(null, () => console.log(\"No user logged in\"))\n    .exhaustive();\n}\n```\n\nThis TypeScript example using `ts-pattern` demonstrates similar capabilities to the Rust version, including pattern matching on complex structures, guard conditions, and exhaustiveness checking.\n\n## Practical Use Cases\n\nPattern matching shines in several real-world scenarios:\n\n1. **State Machines**: Managing complex application states and transitions.\n2. **Data Parsing**: Handling various data formats in ETL (Extract, Transform, Load) processes.\n3. **Error Handling**: Providing detailed and context-specific error messages.\n4. **Game Development**: Managing different game states, events, or character behaviors.\n5. **Compiler Design**: Parsing and processing abstract syntax trees.\n\n## Conclusion\n\nPattern matching, whether native in Rust or simulated in TypeScript, offers powerful tools for creating cleaner, more efficient, and robust code. As you explore these techniques, consider how they can enhance your projects and coding style.","src/content/blog/07_pattern-matching.mdx",[138],"./images/07.webp","b0006a24b7d62a07","01_tech_stack_2023",{"id":140,"data":142,"body":147,"filePath":148,"digest":149,"deferredRender":26},{"publishDate":143,"tags":144,"title":146},["Date","2023-07-28T00:00:00.000Z"],[145],"tier list","My (S-tier) tech stack for 2023","The frontend ecosystem is notorious for having a new framework every week, as illustrated on the famous website [https://dayssincelastjavascriptframework.com>](https://dayssincelastjavascriptframework.com>). While some may find it difficult to keep up or even see it as a reason to not get into frontend development, you should know that frontend development is still rather young. The current state of the web has been evolving for only about 15 years, while the backend development world has been established for 50 years. We have been setting new standards and finding our ground and vision for where we want to go. We have transitioned from server-side applications where we ran PHP code on the server and served plain JavaScript functions to the browser, to full single-page applications that run 10mb JavaScript scripts with an entire application inside, and back again to running on the server, but now it's using React components.\n\nWe are finding our sweet spot where we can innovate in shorter cycles and set a great foundation to build on. Having said this, I am just a fiend for trying out the latest and greatest. I try the latest libraries and find solutions for the annoyances of the past.\n\nThis is my list of technologies I use or would use in my projects this year:\n\n- **React**; while this is still my main framework, I am always trying out other frameworks\n- **Typescript**; types are a must for me, and I am not going back\n  -- **tiny-invariant**; a great library for throwing errors with a message. Usefull to reduce branching and typesafety.\n\n- **tRPC**; providing type safety from back to frontend without any code generation\n- **Radix**; a great UI library with a great design system\n- **clsx**; a utility for conditionally adding classes to elements\n- **NextJS**; the best framework for React\n- **Tailwind**; a utility-first CSS framework. The ease of use of typing classes as a create my components\n- **Zod**; the best validation library for Typescript\n- **React Query**; caching and fetching data from the server, with a great dev experience. My go to library for not using GraphQL\n- **React Table**; you can't do wrong with this table library. A headless library that gives you all the functionality that you want from aa data table. Anything from the [Tanstack](https://tanstack.com)\n- **React Hook Form**; a form library that uses `ref` instead of state. Optimizes performance and gives you a great dev experience\n- **Prisma / Drizzle**; a great ORM for Typescript but I am trying to switch to Drizzle for the ease of use of the query builder\n- **Lucide React**; open source icons\n- **sonner**; a simple library for showing toast\n- **Zact**; using zod for NextJS server actions\n- **type-fest**; more utility types\n\nOther than technologies in my stack, I also use the following services:\n\n- **Stripe**; payment system\n- **Clerk (auth)**; alternative to Auth0 but built for the best DX\n- **Vercel**; I still host everything on Vercel. The ease of use and the great DX is unmatched\n- **Supabase**; database as a service\n\nEverything on here is about \\_D_eveloper \\_E_xperience. I believe a great DX are the foundation of setting an environment where a developer ca thrive. And a motivated developer === great application. Very nice.","src/content/blog/01_tech_stack_2023.mdx","ede2202c9f53412c","11_errors_as_values",{"id":150,"data":152,"body":158,"filePath":159,"assetImports":160,"digest":162,"deferredRender":26},{"cover":153,"description":154,"publishDate":155,"tags":156,"title":157},"__ASTRO_IMAGE_./images/11.webp","Learn how to embrace errors as values in your JavaScript and TypeScript applications. This approach makes error handling explicit and local to where the operation occurs, while also improving type safety and composability.",["Date","2026-01-02T00:00:00.000Z"],[18,118],"Errors as Values: Rethinking JavaScript Error Handling","# Beyond Try-Catch: Modern Error Handling Patterns in JavaScript\n\nError handling in JavaScript has come a long way from the days of simple try-catch blocks. While I've previously covered implementing [Result types in TypeScript](./06_error_handling_in_typescript), today let's explore broader patterns and emerging trends in JavaScript error handling.\n\n## The Evolution of Error Handling\n\nJavaScript's error handling has evolved through several phases:\n\n1. Basic try-catch blocks (ES3)\n2. Promise-based error handling (ES6)\n3. Async/await error handling (ES2017)\n4. Value-based error handling (Modern patterns)\n\n## Error Handling in the Async World\n\nOne area where traditional try-catch falls short is with asynchronous operations. Consider this common pattern:\n\n```javascript\n// Traditional approach\nasync function fetchUser(id) {\n  try {\n    const response = await api.get(`/users/${id}`);\n    return response.data;\n  } catch (error) {\n    // What kind of error is this?\n    // Network error? 404? 500? Validation error?\n    console.error(error);\n    throw error;\n  }\n}\n```\n\nThis presents several problems:\n\n- Error type ambiguity\n- Loss of error context\n- Difficulty in testing\n- Mixing of concerns\n\n## Modern Patterns for Better Error Handling\n\n### Pattern 1: Domain-Specific Error Types\n\nInstead of generic errors, create specific error types for different failure modes:\n\n```javascript\nclass APIError extends Error {\n  constructor(status, message, details) {\n    super(message);\n    this.status = status;\n    this.details = details;\n    this.name = 'APIError';\n  }\n}\n\nclass ValidationError extends Error {\n  constructor(fields) {\n    super('Validation Failed');\n    this.fields = fields;\n    this.name = 'ValidationError';\n  }\n}\n```\n\n### Pattern 2: Error Factories\n\nCreate factories that standardize error creation across your application:\n\n```javascript\nconst ErrorFactory = {\n  network(message, details) {\n    return new APIError(0, message, { type: 'network', ...details });\n  },\n  notFound(resource, id) {\n    return new APIError(404, `${resource} not found`, { id });\n  },\n  validation(fields) {\n    return new ValidationError(fields);\n  }\n};\n```\n\n### Pattern 3: Error Boundaries in Frontend Applications\n\nWhile React has Error Boundaries, we can implement similar patterns in vanilla JavaScript:\n\n```javascript\nclass ErrorBoundary {\n  constructor(fallback) {\n    this.fallback = fallback;\n  }\n\n  async wrap(promise) {\n    try {\n      return await promise;\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        return this.fallback.handleValidation(error);\n      }\n      if (error instanceof APIError) {\n        return this.fallback.handleAPI(error);\n      }\n      return this.fallback.handleUnexpected(error);\n    }\n  }\n}\n```\n\n## Looking to the Future: Effect Systems\n\nThe JavaScript ecosystem is continuously evolving, and one exciting development is the emergence of effect systems. Libraries like `effect.schema` promise to bring powerful error handling capabilities similar to what we see in languages like Haskell or PureScript.\n\nWhile I haven't personally used `effect.schema` in production yet, it's on my radar for future projects. The library aims to provide:\n\n- Type-safe error handling\n- Better composition of effects\n- Runtime validation\n- Improved error tracking\n\n## Choosing the Right Approach\n\nThe approach you choose should depend on your specific needs:\n\n1. For simple applications, traditional try-catch might be sufficient\n2. For TypeScript projects, consider the Result type pattern (covered in my previous post)\n3. For large applications, domain-specific error types and factories\n4. For cutting-edge projects, explore effect systems\n\n## Building a Culture of Good Error Handling\n\nGood error handling isn't just about the technical implementation—it's about building a culture where errors are:\n\n- Expected and planned for\n- Well-documented\n- Easy to debug\n- Meaningful to users\n\n## Conclusion\n\nWhile my previous post focused on implementing the Result type in TypeScript, this broader look at error handling patterns shows there's no one-size-fits-all solution. The key is choosing patterns that make your code more maintainable and your errors more meaningful.\n\nThe JavaScript ecosystem continues to evolve, and with libraries like ts-results and effect.schema gaining traction, we have more tools than ever for handling errors effectively. The future of error handling in JavaScript looks promising, moving beyond simple try-catch blocks to more sophisticated patterns that help us build more reliable applications.\n\nWhat patterns have you found most effective in your projects? I'd love to hear about your experiences in the comments below.","src/content/blog/11_errors_as_values.mdx",[161],"./images/11.webp","650055201b73127c"]