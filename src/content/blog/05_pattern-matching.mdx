---
title: Pattern matching in Typescript
tags: [react, typescript, rust ]
publishDate: 2023-10-20
draft: true
---

Pattern matching is a powerful technique in programming that allows developers to match the structure of data against a set of predefined patterns. It allows you to extract and manipulate data based on its shape, leading to more expressive and readable code. While pattern matching is mostly known in functional programming languages, I first got introduced to it in Rust. In this blog post, we will explore what pattern matching is and how we can introduce it in Tyescript. 

First we look at how pattern matching is done in Rust. Rust enables you to use pattern matching by the `match` keyword. Here we see that the syntax consist of keyword  

```rust
match VALUE {
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
    PATTERN => EXPRESSION,
}
```

pattern matching is more extensive and flexible, with constructs like `match` expressions. Here's an example:

```rust
enum LogLevel {
    Info,
    Warning,
    Error,
}

fn log_level_to_string(level: LogLevel) -> String {
    match level {
        LogLevel::Info => String::from("Information"),
        LogLevel::Warning => String::from("Warning"),
        LogLevel::Error => String::from("Error"),
    }
}
```

To really get the full type safe feeling Rust forces exhaustive checking. This means that all the possible branches are being handled in your code. This may sound like a small thing, but it can be a huge help in preventing bugs. 


In summary, while TypeScript's pattern matching relies on discriminated unions and the `switch` statement, Rust provides a more comprehensive and expressive pattern matching experience. Understanding the pattern matching capabilities of each language empowers developers to choose the right approach based on their project's requirements.

Pattern matching is a powerful tool for handling complex data structures and improving code readability. Whether you're working with TypeScript or Rust, embracing pattern matching unlocks new possibilities and helps write elegant and robust software.


In TypeScript, pattern matching is achieved using discriminated unions and the `switch` statement. Here's an example:

```typescript
type Shape =
  | { kind: 'circle'; radius: number }
  | { kind: 'square'; sideLength: number }
  | { kind: 'rectangle'; width: number; height: number };

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius ** 2;
    case 'square':
      return shape.sideLength ** 2;
    case 'rectangle':
      return shape.width * shape.height;
    default:
      throw new Error('Invalid shape');
  }
}
```

Remember to explore the respective documentation and examples for TypeScript and Rust to dive deeper into their pattern matching capabilities. 

## Exhaustive checking

One additional feature that ensures type safe branching is `exhaustive deps`. This ensures that all the possible branches are being handled in your code. This may sound like a small thing, but it can be a huge help in preventing bugs. 


```typescript
type Shape =
  | { kind: 'circle'; radius: number }
  | { kind: 'square'; sideLength: number }
  | { kind: 'rectangle'; width: number; height: number };
```

Recently, I had a need to create a useful object to store the paths of my application. Initially, I started with a basic version using TypeScript:

```typescript
const paths = {
  home: '/',
  user: '/users',
} as const;

type Path = keyof typeof paths;
```

This allowed me to define the paths and use them as type-safe keys. However, I realized that it would be even better if we could achieve type safety for dynamic paths, such as paths that include an ID. For instance, something like this:

```typescript
const paths = {
  home: '/',
  user: '/users',
  users(id: string): `/users/${id}`,
} as const;
```

Imagine if the TypeScript compiler could help us by ensuring that all the required data is provided. Unfortunately, we currently have to manually handle such cases, like this:

```typescript
const paths = {
  home: '/',
  user: '/users',
  usersId: (id: string) => `/users/${id}`,
} as const;
```

With this approach, we ensure that the paths are correctly constructed and that the compiler enforces type safety. By using a function, we can achieve a pattern-matching-like behavior in TypeScript. For instance, we can retrieve the dynamic path by calling the function with the appropriate argument:

```typescript
const userId = 'user123';
const usersPath = paths.usersId(userId); // Result: "/users/user123"
const usersPath = paths.usersId; // Valid syntax instead of enforcing an argument 
```

This allows us to construct the path dynamically and guarantees that we provide the required data (in this case, the user ID). As a result, we achieve a more robust and type-safe way of handling paths in our application.

By utilizing this pattern, we can ensure that our paths are always accurate and that we catch any errors early in the development process, thanks to TypeScript's type-checking capabilities. This not only leads to more reliable code but also improves the overall readability and maintainability of our application.
