---
title: Another way to manage your state
tags: [state management, frontend]
summary: After dropping Redux, I've been using Zustand for a while. But recently, I've been experimenting with Signals, a new state management library that uses signals to manage state changes. A new concept for some but it feels rather easy to understand.
publishDate: 2023-04-22
draft: true
---

Let's dive into the exciting world of state management in React and compare the differences between Zustand, Redux, and Signals.

As a developer, you might have experienced the pain of managing state in a large-scale React application. Luckily, there are several state management libraries available to help you out. But with so many options, it can be hard to choose the right one for your project.

Enter Zustand, Redux, and Signals - three popular state management libraries that offer different approaches to solving the same problem. Let's take a closer look at each of them.

## Zustand

Zustand is a relatively new state management library that has gained popularity in the React community for its simplicity and flexibility. With Zustand, you can manage your application's state using a combination of React hooks and a simple API. Here's an example of how to use Zustand in a React component:

```typescript
import create from "zustand";

type State = {
  count: number;
  increment: () => void;
};

const useStore = create<State>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

function Counter() {
  const { count, increment } = useStore();
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

In this example, we define our state and its API using the `create` function from Zustand. Then, we use the `useStore` hook to access our state in our `Counter` component. Whenever we call `increment`, the state is updated using the `set` function provided by Zustand.

## Redux

Redux is a battle-tested state management library that has been around for several years. With Redux, you can manage your application's state in a predictable and immutable way using actions and reducers. Here's an example of how to use Redux in a React component with TypeScript:

javascriptCopy code

```typescript
import { useDispatch, useSelector } from "react-redux";
import { RootState } from "./store";

type Props = {
  text: string;
};

function Message({ text }: Props) {
  const dispatch = useDispatch();
  const count = useSelector((state: RootState) => state.count);

  function handleClick() {
    dispatch({ type: "INCREMENT" });
  }

  return (
    <div>
      <p>{text}</p>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

In this example, we define our state in a Redux store and access it using the `useSelector` hook. Whenever we call `handleClick`, the state is updated by dispatching an action to a reducer defined in our store.

## Signals

Signals is a new type of state management library that uses the concept of signals to manage state changes. With Signals, you can define signals to trigger state changes in response to specific events. Here's an example of how to use Signals in a React component with TypeScript:

```typescript
import { createSignal } from 'solid-js';
import { createState, createEffect } from 'solid-js';

type State = {
  count: number;
};

const initialState: State = {
  count: 0,
};

const [incrementSignal, increment] = createSignal<void>();

const state = createState<State>(initialState);
createEffect(() => {
  if (incrementSignal()) {
    state.count++;
  }
});

function Counter() {
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );

```
