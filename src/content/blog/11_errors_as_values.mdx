---
title: "Errors as Values: Rethinking JavaScript Error Handling"
tags: [typescript, error-handling]
publishDate: 2025-10-20
description: Beyond try-catch -- modern patterns for handling errors in JavaScript and TypeScript.
cover: "./images/11.webp"
draft: true
---

When you start out as a developer, you mostly think about the happy path. As you get further in your career you run into more cases where things just don't work the way you expected -- and you have no idea why.

I've previously written about [Result types in TypeScript](./06_error_handling_in_typescript). This post takes a broader look at error handling patterns and where things are heading.

## The Evolution of Error Handling

JavaScript's error handling has evolved through several phases:

1. Basic try-catch blocks (ES3)
2. Promise-based error handling (ES6)
3. Async/await error handling (ES2017)
4. Value-based error handling (Modern patterns)

## Error Handling in the Async World

One area where traditional try-catch falls short is with asynchronous operations. Consider this common pattern:

```javascript
// Traditional approach
async function fetchUser(id) {
  try {
    const response = await api.get(`/users/${id}`);
    return response.data;
  } catch (error) {
    // What kind of error is this?
    // Network error? 404? 500? Validation error?
    console.error(error);
    throw error;
  }
}
```

This presents several problems:

- Error type ambiguity
- Loss of error context
- Difficulty in testing
- Mixing of concerns

## Modern Patterns for Better Error Handling

### Pattern 1: Domain-Specific Error Types

Instead of generic errors, create specific error types for different failure modes:

```javascript
class APIError extends Error {
  constructor(status, message, details) {
    super(message);
    this.status = status;
    this.details = details;
    this.name = 'APIError';
  }
}

class ValidationError extends Error {
  constructor(fields) {
    super('Validation Failed');
    this.fields = fields;
    this.name = 'ValidationError';
  }
}
```

### Pattern 2: Error Factories

Create factories that standardize error creation across your application:

```javascript
const ErrorFactory = {
  network(message, details) {
    return new APIError(0, message, { type: 'network', ...details });
  },
  notFound(resource, id) {
    return new APIError(404, `${resource} not found`, { id });
  },
  validation(fields) {
    return new ValidationError(fields);
  }
};
```

### Pattern 3: Error Boundaries in Frontend Applications

While React has Error Boundaries, we can implement similar patterns in vanilla JavaScript:

```javascript
class ErrorBoundary {
  constructor(fallback) {
    this.fallback = fallback;
  }

  async wrap(promise) {
    try {
      return await promise;
    } catch (error) {
      if (error instanceof ValidationError) {
        return this.fallback.handleValidation(error);
      }
      if (error instanceof APIError) {
        return this.fallback.handleAPI(error);
      }
      return this.fallback.handleUnexpected(error);
    }
  }
}
```

## Looking Ahead: Effect Systems

One thing I'm keeping an eye on is effect systems. Libraries like `effect.schema` are bringing ideas from Haskell and PureScript into the JavaScript world.

I haven't used it in production yet, but it's on my list. What it promises:

- Type-safe error handling
- Better composition of effects
- Runtime validation
- Improved error tracking

## Choosing the Right Approach

The approach you choose should depend on your specific needs:

1. For simple applications, traditional try-catch might be sufficient
2. For TypeScript projects, consider the Result type pattern (covered in my previous post)
3. For large applications, domain-specific error types and factories
4. For cutting-edge projects, explore effect systems

## Building Good Error Handling Habits

The technical patterns matter, but so does the mindset. Errors should be:

- Expected and planned for
- Well-documented
- Easy to debug
- Meaningful to the person reading them

There's no one-size-fits-all approach. Pick the patterns that make your code more maintainable and your errors more useful. With libraries like ts-results and effect.schema gaining traction, we have more options than ever -- the hard part is choosing the right one for your context.
