---
title: Principles
layout: ../layouts/default.astro
description: The core philosophies that guide my work as a senior engineer. These are not rigid rules, but a compass for decision making in a complex field.
toc: true
---

## Foundation: Communication & Growth

### Communicate to Collaborate

Master both written and spoken communication as your foundation. Every aspect of software development—from code reviews to architectural decisions—depends on clear collaboration. Give and receive feedback effectively, listen with empathy, and build solutions as a team rather than in isolation.

The best technical solution means nothing if you can't explain why it matters or convince others to adopt it. Communication isn't separate from engineering—it's the underlying layer on which all engineering happens.

### Learn the Rules to Break Them Wisely

Understand your organization's methodology so thoroughly that you recognize when and how to bend the rules. Whether your team uses Kanban, Scrum, or maintains a Tech Radar, navigate these frameworks while keeping the bigger picture in mind.

Methodologies exist to solve problems, not to be followed blindly. The mark of maturity is knowing which rules serve your current context and which ones are getting in the way. This connects directly to **Adapt Your Approach to the Context**—both require understanding the "why" behind the "what."

### Study Your Environment, Not Just Your Code

Invest time learning your environment beyond the technical stack. Understand company culture, hierarchy, and team dynamics. Use this knowledge to adapt your approach—whether you're working in a fast-moving startup or a structured enterprise environment.

Technical decisions don't exist in a vacuum. The "best" architecture for a two-person startup differs dramatically from the "best" architecture for a regulated enterprise. Your environment shapes what's possible, what's valuable, and what's waste.

### Embrace Discomfort to Grow

Make reliability come from adaptability in our fast changing field. Admit mistakes publicly, hold yourself accountable, and actively seek uncomfortable learning opportunities. Don't avoid problems you don't understand—lean into them.

The problems you avoid become the gaps in your expertise. Every senior engineer has a catalog of "I should have learned this years ago" moments. The difference is whether you keep expanding that catalog or start closing those gaps. Discomfort is the price of growth—and growth is the only constant in software engineering.

This applies not just to technical skills, but also to interpersonal skills. Growth happens at the edge of your comfort zone.

### Own Problems, Propose Solutions

Don't just identify problems—propose solutions. Rather than throwing issues "over the fence," take ownership of challenges and work collaboratively to resolve them, regardless of your personality type or role boundaries.

This principle mirrors the **Hollywood Principle** in modular design: don't wait for someone else to solve your problems, but also don't reach into other people's domains uninvited. Own your boundary, propose across boundaries, collaborate at interfaces.

### Words Matter And Start Living In An Organization

Choose your words carefully—they shape reality within your organization. When you propose a "quick workaround" or "temporary solution," others hear "the solution." That casual compromise becomes the documented approach. That "just for now" architecture lives in production for years. Be precise: call workarounds what they are, name technical debt explicitly, and say "I don't know" instead of dressing up uncertainty as confidence. Your words don't just describe decisions—they legitimize them and create precedents that persist long after you've moved on.

## Software Craft: Quality & Simplicity

### Build Quality In, Don't Bolt It On

Weave quality into every decision rather than treating it as an afterthought. Embed testing, refactoring, and maintainability into your daily work. Make quality improvements part of feature development rather than separate initiatives requiring special permission.

Quality isn't a phase or a separate backlog item. It's a property that emerges from how you work daily. Every commit either increases or decreases the system's quality debt. Choose deliberately with each change whether you're investing or borrowing against the future.

### Understand Needs, Not Just Requirements

Focus on what your stakeholders actually need—not just what they ask for. Sometimes this means building a proof of concept first, other times it requires upfront design work. Calibrate your approach to avoid unnecessary delays while maintaining standards.

Requirements are compressed interpretations of needs, lossy by nature. Your job isn't to implement specifications perfectly—it's to solve problems effectively. This often means questioning the requirements themselves, which connects to **Question Schemas, Don't Worship Them**: both principles reject literal interpretation in favor of understanding intent.

### Simplify Relentlessly

Treat simplicity as the ultimate sophistication in software. Constantly work to reduce complexity through modular design, proper separation of concerns, and thoughtful testing strategies. Use these as adjustable levers, not rigid rules.

Simple code is easier to read, test, modify, and delete. Complexity is the enemy of reliability, security, and velocity. Every abstraction, every layer, every pattern should justify its existence by reducing overall complexity—not just local complexity at the expense of global understanding.

### Code Never Dies, You Have to Kill It

A testament by Grady Booch in the podcast *The Pragmatic Engineer*: "Old code never dies, you have to kill it."

Code has inertia. Once written, it persists through momentum rather than value. Dead features linger in production. Unused functions remain "just in case." Deprecated APIs stick around because deletion feels riskier than retention. But every line of code you keep is code you maintain, secure, and pay to understand.

Active code stewardship means regularly identifying what no longer serves its purpose and having the courage to remove it. Deletion is a feature. An empty pull request that removes 1,000 lines of obsolete code is often more valuable than one that adds 1,000 lines of new features.

The best codebases aren't those that never make mistakes—they're those that aggressively prune the mistakes they've made.

### The Code That Changes Together Stays Together

Keep related code physically close to each other. When multiple pieces of code consistently change together during feature development or bug fixes, they share coupling that should be reflected in your file structure. This principle helps reduce the cognitive overhead of making changes and makes it easier to understand how different parts of your system relate to each other.

This is [cohesion](https://en.wikipedia.org/wiki/Cohesion_(computer_science)) made practical: if every time you modify function A, you also modify function B, they belong in the same module. Your version control history reveals the true coupling in your system—patterns of co-change matter more than theoretical architectural boundaries.

High cohesion within modules, loose coupling between them. The code that changes together should live together; the code that changes independently should live apart.

## Data Validation Principles

In distributed systems, validation isn't paranoia—it's architecture. Every boundary between systems is a point where assumptions can break, schemas can drift, and malicious input can enter. Runtime validation is your defense against the gap between what you expect and what actually arrives.

### Treat Every External Interface as a Trust Boundary

Every connection to external systems—APIs, databases, file uploads—represents a point where your assumptions might break. Validate all data crossing these boundaries, regardless of how confident your type declarations make you feel.

Types describe structure; validation enforces invariants. Your type system can't protect you from `{"age": -5}` or `{"email": "not-an-email"}`. Runtime validation catches what compile-time checking cannot: business rules, data integrity constraints, and malicious input.

### Question Schemas, Don't Worship Them

OpenAPI and Swagger schemas serve as excellent documentation and client generation tools, but treat them as guidelines, not gospel. API providers change implementations without updating schemas more often than you'd expect, creating dangerous gaps between expectation and reality.

This echoes **Understand Needs, Not Just Requirements**: schemas document intent imperfectly, just as requirements do. Trust, but verify. Use schemas as starting points, not contracts.

### Validate to Defend, Not Just to Parse

Blindly trusting input shapes creates security vulnerabilities, especially during parsing and deserialization. Runtime validation acts as a critical defense layer against injection attacks, malformed data, and unexpected payloads that slip past type checking.

Defense in depth means validating at every boundary, even when you "control" both sides. Your authentication service might be secure today, but validation ensures your user service doesn't blindly trust whatever arrives claiming to be authenticated.

### Invest in Validation for Better Developer Experience

Robust runtime validation feels like overhead until you need to debug a production issue. Proper validation makes it easier to trace problems, understand data flows, and maintain system integrity. The upfront cost pays dividends in reduced debugging time and clearer error messages.

Good validation turns "something broke in production" into "received invalid email format from the checkout service at 14:23:47 UTC." Specificity in error handling is worth its weight in gold when you're troubleshooting at 3 AM.

## Rob Pike's 5 Principles of Programming

Rob Pike, co-creator of Go and UTF-8, and a Unix pioneer at Bell Labs, distilled decades of systems programming wisdom into five timeless rules. These principles, from his [*Notes on Programming in C*](https://www.lysator.liu.se/c/pikestyle.html), remain as relevant today as when he wrote them.

### 1. Don't Guess Where the Bottlenecks Are

You can't tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don't try to second guess and put in a speed hack until you've proven that's where the bottleneck is.

### 2. Measure Before You Optimize

Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest.

### 3. Keep It Simple When N Is Small

Fancy algorithms are slow when $N$ is small, and $N$ is usually small. Fancy algorithms have big constants. Until you know that $N$ is frequently going to be big, don't get fancy. (Even if $N$ does get big, use Rule 2 first.)

### 4. Choose Simple Over Clever

Fancy algorithms are buggier than simple ones and much harder to implement correctly. Favor simple algorithms paired with simple data structures. Clever code impresses other engineers; simple code ships and works.

### 5. Let Data Drive Your Design

Choose the right data structures first, and the algorithms will often become obvious. Data structures, not algorithms, are central to programming. Well-organized data makes complex problems simple; poorly chosen structures make simple problems complex.

## Modular Design Principles

### Separation of Policy from Mechanism

**Mechanism** = *How* something works (the implementation)  
**Policy** = *When/whether* something should happen (the business rules)

Keep mechanism in the component. Push policy to the caller. Components should implement capabilities without encoding business rules about when to use them. The caller, who understands the context, decides when and how to invoke those capabilities. This separation creates flexible, reusable components that adapt to different contexts without modification.

This is a core concept in operating system design, articulated in papers like [*The Structuring of Systems Using Upcalls*](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy) and fundamental to Unix philosophy. Build tools that do one thing well, then let users compose them according to their needs.

### Hollywood Principle: "Don't Call Us, We'll Call You"

Components shouldn't reach out to query their environment or ask for context. Instead, they receive everything they need through their interface.

When a component "calls out" to check environment variables, global state, or external context, it creates hidden dependencies. Dependencies should be explicit in function signatures and constructors, making them visible and testable. The caller provides what's needed; the component doesn't go looking for it.

This principle is the foundation of [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) and inversion of control containers. It connects to **Own Problems, Propose Solutions**: your component shouldn't reach across boundaries to solve problems outside its domain.

### Inversion of Control (IoC)

The caller controls the behavior, not the callee.

Rather than components making decisions about their own execution based on inspecting context, they accept configuration that guides their behavior. This inverts traditional control flow where functions reach into their environment to determine what to do. Control stays at the boundaries where context naturally exists.

[Inversion of Control](https://en.wikipedia.org/wiki/Inversion_of_control) makes testing trivial: instead of mocking global state, you pass in test doubles through the normal interface. Your component doesn't know whether it's in production or a test—it just does what it's told with what it's given.

### Information Hiding Principle

Hide implementation details, expose only necessary interfaces.

Each module should encapsulate design decisions that are likely to change, exposing only stable interfaces. When internal implementation changes, the change shouldn't ripple through the system. This is David Parnas's foundational concept from his 1972 paper [*On the Criteria To Be Used in Decomposing Systems into Modules*](https://en.wikipedia.org/wiki/Information_hiding).

Information hiding isn't about secrecy—it's about managing dependencies. Hide anything that might change. Expose only what must be known. This creates modules that can evolve independently without breaking their clients.

### Interface Segregation: Pass Only What's Needed

Components should receive the minimal information required to perform their function, not entire domain objects. This reduces coupling, makes dependencies explicit, and prevents components from accessing data they shouldn't care about.

When you pass a complete domain object, you create unnecessary coupling to its entire structure. Extract specific values at the boundary and pass only those. A function that needs an email address shouldn't receive an entire User object—it should receive a string.

This is one of the [SOLID principles](https://en.wikipedia.org/wiki/Interface_segregation_principle): clients shouldn't be forced to depend on interfaces they don't use. Apply it not just to interfaces, but to function parameters. The fewer things a function depends on, the easier it is to understand, test, and reuse.

### Law of Demeter (Principle of Least Knowledge)

Only talk to your immediate friends, don't reach through objects.

A method should only call methods on itself, its parameters, objects it creates, or its direct fields. Don't chain calls through objects you don't own. When you write `object.getA().getB().getC()`, you couple yourself to the internal structure of multiple objects. If any part of that chain changes, your code breaks.

The [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter), formulated at Northeastern University in 1987, is also called the "principle of least knowledge." It's not about preventing all method chains—it's about reducing coupling to distant parts of your system.

Instead, ask objects to provide what you need directly, or extract the values you need at the boundary where you have proper context. This connects back to **Interface Segregation**: both principles push you toward minimal, explicit dependencies rather than reaching through layers of abstraction.

## Leadership: Principal Engineer Principles

### Lead by Crafting, Not Just Directing

Stay hands-on and lead through exemplary work. Deliver designs, algorithms, and implementations that set the standard for engineering excellence. Only by staying close to the details can you earn the respect needed to be an effective technical leader.

Authority in engineering comes from demonstrated competence, not granted title. Your influence grows from the quality of your contributions, not the weight of your opinions. Lead by showing what's possible, not by telling others what to do.

### Embrace Technical Risk and Complexity

Tackle intrinsically hard problems that others avoid. Venture beyond comfortable approaches when the problem demands it. Acquire new expertise as needed, pioneer unexplored spaces, and show others what's possible through fearless technical exploration.

Senior engineers are comfortable in complexity because they've developed tools for managing it. They're not smarter—they're more systematic. They know when to **Simplify Relentlessly** and when to accept necessary complexity. The art is knowing the difference.

### Shape Culture Through Empathy

Build an inclusive engineering environment where everyone feels heard, respected, and empowered. Be conscious of how your words and presence impact others, especially those with less influence. Take responsibility for that impact and foster productive relationships across teams and disciplines.

Technical leadership without emotional intelligence is just architecture documents. Your ability to influence depends on your ability to understand others' perspectives, constraints, and motivations. This directly enables **Communicate to Collaborate**—empathy is the foundation of effective communication.

### Transform Complexity into Clarity

Bring clarity to complex problems and demonstrate smart ways to simplify. Frame each challenge in its customer and business context, then distill it to its essence. Question assumptions, illuminate hidden pitfalls, and drive shared understanding across diverse stakeholders.

The most valuable skill in senior engineering isn't writing code—it's clarifying problems. Most technical failures trace back to solving the wrong problem or misunderstanding the real constraints. Clarity is force multiplication.

### Adapt Your Approach to the Context

Adjust your methods to meet the needs of each team, project, and product. Actively seek differing perspectives and remain willing to change your mind as you learn. Recognize that multiple viable solutions often exist—and sometimes the best solution is solving a different problem entirely.

This echoes **Learn the Rules to Break Them Wisely**: both require reading context and responding appropriately rather than applying rigid patterns. One-size-fits-all solutions are a sign of inexperience, not expertise.

### Honor the Systems You Inherit

Appreciate the value of working systems and the hard-won lessons they embody. Understand that many problems aren't fundamentally new—respect what came before while improving upon it thoughtfully.

Every "legacy system" was once a modern greenfield project built by smart people facing constraints you might not fully understand. Before refactoring or replacing, learn why it is the way it is. Often the seemingly stupid decisions were actually intelligent tradeoffs given information available at the time.

This connects to **Code Never Dies, You Have to Kill It**: respect existing code enough to understand it, but be willing to delete it when its time has passed.

### Learn Continuously, Teach Broadly

Never stop learning technical knowledge, and share that learning across the organization. Educate others about emerging trends, technologies, and approaches. Combine vision with discretion to drive technology choices that can be truly game-changing.

Your value multiplies when you teach others. One person writing great code creates local impact. One person raising the capability of an entire team creates systemic impact. The best engineers are also teachers, whether through code review, documentation, or mentorship.

### Create Lasting Impact Beyond Code

Aim higher than just "delivering results." Make a lasting impact that echoes through the technology, product, and company culture. Amplify your influence by aligning teams toward coherent architectural strategies that outlast any single project.

The most important work isn't always the most visible work. Sometimes the greatest impact comes from killing a bad project, establishing a standard, or teaching a principle that propagates through the organization. Think in systems, not features.
