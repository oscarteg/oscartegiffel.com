---
title: Principles
layout: ../layouts/default.astro
description: The core philosophies that guide my work as a senior engineer. These are not rigid rules, but a compass for decision making in a complex field.
toc: true
---

## Foundation: Communication & Growth

### Communicate to Collaborate

Communication is the foundation. Every part of software development (code reviews, architectural decisions, even how you name things) depends on clear collaboration. Give feedback well, receive it better, and build things as a team rather than in isolation.

The best technical solution means nothing if you can't explain why it matters. Communication isn't separate from engineering. It's the layer everything else runs on.

### Learn the Rules to Break Them Wisely

Understand your organization's methodology so well that you know when to bend the rules. Kanban, Scrum, Tech Radar. Navigate these frameworks, but keep the bigger picture in mind.

Methodologies exist to solve problems, not to be followed blindly. The mark of maturity is knowing which rules serve your current context and which ones are getting in the way. Same idea as [adapting to context](#adapt-your-approach-to-the-context): both come down to understanding the "why" behind the "what."

### Study Your Environment, Not Just Your Code

Learn the environment beyond the technical stack. Company culture, hierarchy, team dynamics. This stuff matters. Use it to adapt your approach whether you're in a fast-moving startup or a structured enterprise.

Technical decisions don't exist in a vacuum. The "best" architecture for a two-person startup looks nothing like the "best" architecture for a regulated enterprise. Your environment shapes what's possible, what's valuable, and what's waste.

### Embrace Discomfort to Grow

The problems you avoid become the gaps in your expertise. Every senior engineer has a list of "I should have learned this years ago" moments. The difference is whether you keep growing that list or start closing it.

Admit mistakes publicly. Hold yourself accountable. Seek out the uncomfortable learning opportunities. Don't avoid problems you don't understand. Lean into them. This applies to interpersonal skills just as much as technical ones.

### Own Problems, Propose Solutions

Don't just point at problems. Propose solutions. Instead of throwing issues "over the fence," take ownership and work collaboratively, regardless of your role boundaries.

This mirrors the [Hollywood Principle](#hollywood-principle-dont-call-us-well-call-you) in modular design: don't wait for someone else to fix your problems, but also don't reach into other people's domains uninvited. Own your boundary, propose across boundaries, collaborate at the interfaces.

### Words Matter

Choose your words carefully. They shape reality within your organization. When you call something a "quick workaround" or "temporary solution," others hear "the solution." That casual compromise becomes the documented approach. That "just for now" architecture? It lives in production for years.

Be precise. Call workarounds what they are. Name technical debt explicitly. Say "I don't know" instead of dressing up uncertainty as confidence. Your words don't just describe decisions. They legitimize them and create precedents that stick around long after you've moved on.

## Software Craft: Quality & Simplicity

### Build Quality In

Quality isn't a phase at the end of a project. It's not a separate backlog item. It emerges from how you work daily. Embed testing, refactoring, and maintainability into your regular work instead of treating them as special initiatives that need permission.

Every commit either increases or decreases quality debt. Choose deliberately with each change whether you're investing or borrowing against the future.

### Understand Needs, Not Just Requirements

Focus on what your stakeholders actually need, not just what they ask for. Sometimes that means a proof of concept first, sometimes it means upfront design. Calibrate.

Requirements are compressed interpretations of needs, lossy by nature. Your job isn't to implement specs perfectly. It's to solve problems effectively. This often means questioning the requirements themselves. Same idea as [questioning schemas](#question-schemas-dont-worship-them): both reject literal interpretation in favor of understanding intent.

### Simplify Relentlessly

Simple code is easier to read, test, modify, and delete. Complexity is the enemy of reliability, security, and velocity. Every abstraction, every layer, every pattern should justify its existence by reducing overall complexity, not just local complexity at the expense of global understanding.

Constantly work to reduce complexity through modular design, separation of concerns, and thoughtful testing. Use these as levers, not rigid rules.

### Code Never Dies, You Have to Kill It

Grady Booch said it on *The Pragmatic Engineer*: "Old code never dies, you have to kill it."

Code has inertia. Once written, it persists through momentum rather than value. Dead features linger in production. Unused functions stay "just in case." Deprecated APIs stick around because deletion feels riskier than keeping them. But every line you keep is a line you maintain, secure, and pay to understand.

Deletion is a feature. A pull request that removes 1,000 lines of dead code is often more valuable than one that adds 1,000 lines of new features. The best codebases aren't the ones that never made mistakes. They're the ones that aggressively prune them.

### The Code That Changes Together Stays Together

If every time you modify function A you also modify function B, they belong in the same module. Your version control history reveals the true coupling in your system. Patterns of co-change matter more than theoretical architectural boundaries.

This is [cohesion](https://en.wikipedia.org/wiki/Cohesion_(computer_science)) made practical. High cohesion within modules, loose coupling between them. Code that changes together should live together. Code that changes independently should live apart.

### Don't Guess Where the Bottlenecks Are

You can't tell where a program is going to spend its time. Bottlenecks show up in surprising places. Don't put in a speed hack until you've proven that's where the bottleneck actually is.

### Measure Before You Optimize

Measure. Don't tune for speed until you've measured, and even then don't unless one part of the code overwhelms the rest.

### Keep It Simple When N Is Small

Fancy algorithms are slow when $N$ is small, and $N$ is usually small. Fancy algorithms have big constants. Until you know that $N$ is frequently going to be big, don't get fancy. (Even if $N$ does get big, use the rule above first.)

### Choose Simple Over Clever

Fancy algorithms are buggier than simple ones and much harder to implement correctly. Favor simple algorithms paired with simple data structures. Clever code impresses other engineers; simple code ships and works.

### Let Data Drive Your Design

Choose the right data structures first, and the algorithms will often become obvious. Data structures, not algorithms, are central to programming. Well-organized data makes complex problems simple; poorly chosen structures make simple problems complex.

## Data Validation

In distributed systems, validation isn't paranoia. It's architecture. Every boundary between systems is a point where assumptions break, schemas drift, and bad input enters.

### Treat Every External Interface as a Trust Boundary

Every connection to external systems (APIs, databases, file uploads) is a point where your assumptions might break. Validate everything crossing these boundaries, no matter how confident your type declarations make you feel.

Types describe structure. Validation enforces invariants. Your type system can't protect you from `{"age": -5}` or `{"email": "not-an-email"}`. Runtime validation catches what compile-time checking cannot.

### Question Schemas, Don't Worship Them

OpenAPI and Swagger schemas are great for documentation and client generation. But treat them as guidelines, not gospel. API providers change implementations without updating schemas more often than you'd think.

This echoes [understanding needs over requirements](#understand-needs-not-just-requirements). Schemas document intent imperfectly, just like requirements. Trust, but verify.

### Validate to Defend, Not Just to Parse

Blindly trusting input shapes creates security holes. Runtime validation is a defense layer against injection attacks, malformed data, and unexpected payloads that slip past type checking.

Defense in depth means validating at every boundary, even when you "control" both sides. Your auth service might be secure today, but validation makes sure your user service doesn't blindly trust whatever arrives claiming to be authenticated.

### Invest in Validation for Better DX

Validation feels like overhead until you need to debug a production issue. Good validation turns "something broke in production" into "received invalid email format from the checkout service at 14:23:47 UTC."

That specificity is worth its weight in gold at 3 AM.

## Modular Design

### Separation of Policy from Mechanism

**Mechanism** = *how* something works (the implementation)
**Policy** = *when/whether* something should happen (the business rules)

Keep mechanism in the component. Push policy to the caller. The component implements capabilities. The caller, who understands the context, decides when and how to use them.

This is a core concept in OS design from papers like [*The Structuring of Systems Using Upcalls*](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy) and fundamental to Unix philosophy. Build tools that do one thing well. Let users compose them.

### Hollywood Principle: "Don't Call Us, We'll Call You"

Components shouldn't reach out to query their environment. They receive everything they need through their interface.

When a component checks environment variables, global state, or external context, that's a hidden dependency. Dependencies should be explicit in function signatures and constructors. The caller provides what's needed; the component doesn't go looking for it.

This is the foundation of [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) and inversion of control. Your component shouldn't reach across boundaries to solve problems outside its domain. See also [owning problems](#own-problems-propose-solutions).

### Inversion of Control

The caller controls the behavior, not the callee.

Instead of components inspecting their context to decide what to do, they accept configuration that guides their behavior. Control stays at the boundaries where context naturally exists.

[IoC](https://en.wikipedia.org/wiki/Inversion_of_control) makes testing trivial: instead of mocking global state, you pass in test doubles through the normal interface. Your component doesn't know if it's in production or a test. It just does what it's told with what it's given.

### Information Hiding

Hide implementation details, expose only necessary interfaces.

Each module encapsulates decisions that are likely to change, exposing only stable interfaces. When internals change, the change shouldn't ripple through the system. This is Parnas's foundational concept from his 1972 paper [*On the Criteria To Be Used in Decomposing Systems into Modules*](https://en.wikipedia.org/wiki/Information_hiding).

Information hiding isn't about secrecy. It's about managing dependencies. Hide anything that might change. Expose only what must be known.

### Interface Segregation: Pass Only What's Needed

Don't pass entire domain objects when a component only needs one field. A function that needs an email address shouldn't receive an entire User object. Just pass the string.

When you pass a complete domain object, you couple yourself to its entire structure. Extract the specific values at the boundary and pass only those. This is one of the [SOLID principles](https://en.wikipedia.org/wiki/Interface_segregation_principle). The fewer things a function depends on, the easier it is to understand, test, and reuse.

### Law of Demeter

Only talk to your immediate friends. Don't reach through objects.

When you write `object.getA().getB().getC()`, you couple yourself to the internal structure of multiple objects. If any part of that chain changes, your code breaks. The [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter) isn't about preventing all method chains. It's about reducing coupling to distant parts of your system.

Ask objects to provide what you need directly, or extract values at the boundary. Same idea as [interface segregation](#interface-segregation-pass-only-whats-needed): both push you toward minimal, explicit dependencies.

## Leadership

### Lead by Crafting, Not Just Directing

Stay hands-on. Lead through the quality of your work, not the weight of your title. Deliver designs and implementations that set the standard. You earn respect by staying close to the details, not by directing from a distance.

Authority in engineering comes from demonstrated competence. Your influence grows from the quality of your contributions, not from your opinions.

### Embrace Technical Risk

Take on the hard problems that others avoid. Go beyond comfortable approaches when the problem demands it. Pick up new expertise as needed. Show others what's possible.

Senior engineers aren't more comfortable with complexity because they're smarter. They're more systematic. They know when to [simplify](#simplify-relentlessly) and when to accept necessary complexity. The art is knowing the difference.

### Shape Culture Through Empathy

Be conscious of how your words and presence impact others, especially those with less influence. Technical leadership without emotional intelligence is just architecture documents.

Your ability to influence depends on your ability to understand others' perspectives. Empathy is the foundation of [communication](#communicate-to-collaborate).

### Transform Complexity into Clarity

The most valuable skill in senior engineering isn't writing code. It's clarifying problems. Most technical failures trace back to solving the wrong problem or misunderstanding the real constraints. Frame each challenge in its customer and business context, then distill it to its essence.

Clarity is force multiplication.

### Adapt Your Approach to the Context

Adjust your methods to fit each team, project, and product. Seek differing perspectives. Be willing to change your mind. Multiple viable solutions often exist, and sometimes the best solution is solving a different problem entirely.

This echoes [learning the rules to break them](#learn-the-rules-to-break-them-wisely). Both require reading context instead of applying rigid patterns. One-size-fits-all solutions are a sign of inexperience.

### Honor the Systems You Inherit

Every "legacy system" was once a modern greenfield project built by smart people facing constraints you might not understand. Before refactoring or replacing, learn why it is the way it is. The seemingly stupid decisions were often intelligent tradeoffs given the information available at the time.

This connects to [killing dead code](#code-never-dies-you-have-to-kill-it). Respect existing code enough to understand it, but be willing to delete it when its time has passed.

### Learn Continuously, Teach Broadly

Your value multiplies when you teach others. One person writing great code creates local impact. One person raising the capability of an entire team creates systemic impact.

The best engineers are also teachers, whether through code review, documentation, or mentorship.

### Create Lasting Impact Beyond Code

The most important work isn't always the most visible. Sometimes the greatest impact comes from killing a bad project, establishing a standard, or teaching a principle that propagates through the organization.

Think in systems, not features.
